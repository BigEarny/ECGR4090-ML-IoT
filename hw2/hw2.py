# -*- coding: utf-8 -*-
"""hw2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D0evNI8DuDMa-Ns5ClsZ3Oj_ENLtTdBN
"""

# TensorFlow and tf.keras
import tensorflow as tf

# Helper libraries
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras import Input, layers
from keras_preprocessing import image

import PIL
from PIL import Image
import requests

print(tf.__version__)

# FEB16_LEC
def quick_bar(x):
    return plt.bar(np.arange(len(x)), x)

def grouped_bar(l_values, l_group_names=None): # list of arrays, one for each group
    if l_group_names is None:
        l_group_names = ['']*len(l_values)
    
    frac = 0.8 # each field N has space from N-0.5 to N+0.5 to use. we'll use frac of it
    ind = np.arange(len(l_values[0]))  # the x locations for the groups
    
    width = frac/len(l_values)  # the width of the bars

    fig = plt.gcf()
    ax = plt.gca()
    rects = []
    for i, group_data in enumerate(l_values):
        # the spacing code needs some work.  
        bar_centers = ind-0.5*frac + width/2 + i*width
        rects.append(ax.bar(bar_centers, group_data, width, label=l_group_names[i]))

    ax.set_xticks(ind)
    # ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))
    ax.legend()
    

def plotyy(xdata, y1, y2, color1='tab:red', color2='tab:blue', ylabel1='', ylabel2='', xlabel=''):
    ## adapated from https://matplotlib.org/2.2.5/gallery/api/two_scales.html
    fig = plt.gcf()
    ax1 = plt.gca()
    
    ax1.plot(xdata, y1, color=color1)
    ax1.tick_params(axis='y', labelcolor=color1)    
    ax1.set_ylabel(ylabel1, color=color1) 
    ax1.set_xlabel(xlabel)
    
    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis        
    ax2.set_ylabel(ylabel2, color=color2)  # we already handled the x-label with ax1
    ax2.plot(xdata, y2, color=color2)
    ax2.tick_params(axis='y', labelcolor=color2)

    
    fig.tight_layout()  # otherwise the right y-label is slightly clipped
    return (ax1, ax2)

# FEB16_LEC mnist -> cifar10
cifar10 = tf.keras.datasets.cifar10
(train_images, train_labels), (test_images, test_labels) = cifar10.load_data()
class_names = ['airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']
input_shape = train_images.shape[1:]
print(input_shape)

print(train_images.shape)
print(train_labels.shape)
print(test_images.shape)
print(test_labels.shape)

# FEB16_LEC
idx = 15
plt.figure()
plt.imshow(train_images[idx])
plt.colorbar()
plt.title("Label = {:}".format(class_names[train_labels[idx][0]]))

"""# New Section"""

# FEB_16
plt.figure(figsize=(10,10))
for i in range(25):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(train_images[i], cmap=plt.cm.binary)
    plt.xlabel(class_names[train_labels[i][0]])
plt.show()

model = tf.keras.Sequential([
#   Conv 2D: 32 filters, 3x3 kernel, stride=2 (in both x,y dimensions), "same" padding
#   Conv 2D: 64 filters, 3x3 kernel, stride=2 (in both x,y dimensions),  "same" padding
#   MaxPooling, 2x2 pooling size, 2x2 stride
#   Flatten.
#   Dense (aka Fully Connected) , 1024 units.
#   Dense (aka Fully Connected) , 10 units
    tf.keras.layers.Conv2D( filters=32, kernel_size=(3, 3), strides=(2, 2), padding="same", activation='relu', input_shape=input_shape),
    tf.keras.layers.Conv2D(filters=64, kernel_size=(3, 3), strides=(2, 2), padding="same", activation='relu'),
    
    tf.keras.layers.MaxPool2D(pool_size=(2, 2),strides=(2, 2)),

    layers.Flatten(),

    layers.Dense(1024, activation='relu'),

    layers.Dense(10)])
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

model.summary()

train_hist = model.fit(train_images, train_labels, epochs=50)
model.save('saved_models/cifar_cnn_model')

# FEB16_LEC
train_hist.history
plotyy(np.arange(50), train_hist.history['loss'], train_hist.history['accuracy'],
      ylabel1='Loss', ylabel2='Acc')

test_loss, test_acc = model.evaluate(test_images, test_labels)

idx = 0
ex_img = train_images[idx:idx+1]
ex_out = model.predict(ex_img)
plt.subplot(2,1,1)
plt.imshow(ex_img[0,:,:], cmap='Greys')
plt.title("Label = {:}".format(class_names[train_labels[idx][0]]))
plt.subplot(2,1,2)
plt.bar(np.arange(10), ex_out[0])
print("The model is predicted this to be of group: " + class_names[np.argmax(ex_out[0])])

# Take or find a picture of something that is one of the output classes ('airplane','automobile','bird','cat','deer','dog','frog','horse','ship','truck'). Crop and/or rescale it to 32x32 pixels 
# and run your classifier on it.  Does it correctly label the picture?
print("USE A CUSTOM PICTURE 32x32 pixels")

# Pull picture from a URL instead
im = Image.open(requests.get("https://i.imgur.com/1Lcy9Wd.jpg", stream=True).raw)
im = im.resize((32,32), Image.ANTIALIAS)
ex_in = np.array([image.img_to_array(im, dtype = np.uint8)])
ex_out = model.predict(ex_in)
plt.subplot(2,1,1)
plt.imshow(ex_in[0,:,:])
plt.title("Label = {:}".format(class_names[train_labels[5][0]]))
plt.subplot(2,1,2)
plt.bar(np.arange(10), ex_out[0])
print("The model is predicted this to be of group: " + class_names[np.argmax(ex_out[0])])

# 8.) Repeat steps 2,4,5 with a model where the convolutional layers are 
# replaced with depthwise-separable convolutions.

modelP8 = tf.keras.Sequential([
    tf.keras.layers.DepthwiseConv2D(kernel_size=(3, 3), strides=(2, 2), padding="same", activation='relu', input_shape=input_shape),
    tf.keras.layers.Conv2D(filters=32, kernel_size=(1, 1), activation='relu'),

    tf.keras.layers.DepthwiseConv2D(kernel_size=(3, 3), strides=(2, 2), padding="same", activation='relu'),    
    tf.keras.layers.Conv2D(filters=64, kernel_size=(1, 1), activation='relu'),

    tf.keras.layers.MaxPool2D(pool_size=(2, 2),strides=(2, 2)),

    layers.Flatten(),

    layers.Dense(1024, activation='relu'),

    layers.Dense(10)])
modelP8.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

modelP8.summary()

train_hist = modelP8.fit(train_images, train_labels, epochs=50)
model.save('saved_models/cifar_cnn_model')

train_hist.history
plotyy(np.arange(50), train_hist.history['loss'], train_hist.history['accuracy'],
      ylabel1='Loss', ylabel2='Acc')

test_loss, test_acc = modelP8.evaluate(test_images, test_labels)

im = Image.open(requests.get("https://i.imgur.com/1Lcy9Wd.jpg", stream=True).raw)
im = im.resize((32,32), Image.ANTIALIAS)
ex_in = np.array([image.img_to_array(im, dtype = np.uint8)])
ex_out = modelP8.predict(ex_in)
plt.subplot(2,1,1)
plt.imshow(ex_in[0,:,:])
plt.title("Label = {:}".format(class_names[train_labels[5][0]]))
plt.subplot(2,1,2)
plt.bar(np.arange(10), ex_out[0])
print("The model is predicted this to be of group: " + class_names[np.argmax(ex_out[0])])